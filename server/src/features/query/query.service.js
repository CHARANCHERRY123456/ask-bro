// filepath: [query.service.js](http://_vscodecontentref_/1)
import { askGemini } from '../../utils/geminiClient.js';
import pool from '../../db.js';

export async function processQuestion(question, metadata) {
  console.log('processQuestion called with:', { question, metadata });

  const prompt = `
  You are an expert PostgreSQL assistant working with a very messy, inconsistent, and unreliable database.
  
  Important constraints you must follow exactly:
  
  1. Only use the exact column and table names provided in the metadata below. Never invent or assume names.
  2. Every column used in math (like a + b) must be wrapped in \`CAST(column AS NUMERIC)\` â€” even if you *think* it's numeric.
  3. Every \`COALESCE\` call must cast all values to the same type (e.g. \`COALESCE(CAST(col1 AS TEXT), 'default')\`).
  4. Always filter out NULLs where relevant, especially in WHERE, JOIN, GROUP BY, and ORDER BY clauses.
  5. Do NOT assume column types. Always cast when you're unsure or using comparisons, sorting, math, or filters.
  6. Use LEFT JOIN unless it's 100% safe to assume both sides exist.
  7. Avoid ambiguous functions or PostgreSQL-specific extensions.
  8. Return ONLY a raw SQL string, with no backticks, markdown, or explanations. Do NOT wrap the SQL in \`\`\` or any quotes.
  
  Example of correct style:
  SELECT CAST(col1 AS NUMERIC) + CAST(col2 AS NUMERIC) AS total
  FROM table_x
  WHERE col3 IS NOT NULL;
  
  Metadata (describes tables, columns, and meanings):
  ${JSON.stringify(metadata)}
  
  User Question:
  "${question}"
  
  Your only task is to generate a safe, executable, PostgreSQL-compatible SQL query that answers this question based on the metadata.
  Return just the SQL query string. Nothing else.

  I am getting lots errors while running the SQL query. Please make sure to follow the constraints strictly.
  `;
  
  
  

  console.log('Generated prompt for Gemini:', prompt);

  let sqlQuery = '';
  try {
    sqlQuery = await askGemini(prompt);
    sqlQuery = sqlQuery.replace(/```(?:sql)?/g, '').trim(); // Remove ``` and optional "sql"
    console.log('Received SQL query from Gemini:', sqlQuery);
    sqlQuery = sqlQuery.trim();
  } catch (e) {
    console.error('Error while getting SQL from Gemini:', e.message);
    throw new Error('Failed to get SQL from Gemini: ' + e.message);
  }

  if (!sqlQuery || !/^(SELECT|WITH|SHOW|EXPLAIN|INSERT|UPDATE|DELETE)/i.test(sqlQuery)) {
    console.error('Invalid SQL generated by Gemini:', sqlQuery);
    throw new Error('Invalid SQL generated by Gemini.');
  }

  console.log('Validated SQL query:', sqlQuery);
  return sqlQuery;
}

export async function executeSQL(sqlQuery) {
  console.log('executeSQL called with query:', sqlQuery);

  try {
    const result = await pool.query(sqlQuery);
    console.log('Query executed successfully. Result:', result.rows);
    return result.rows;
  } catch (e) {
    console.error('Error while executing SQL query:', e.message);
    throw new Error('PostgreSQL query failed: ' + e.message);
  }
}

export async function generateAnswerFromResults(sqlQuery, rows) {
  console.log('generateAnswerFromResults called with:', { sqlQuery, rows });

  const prompt = `
    You are a data analyst assistant.

    Given the SQL query:
    ${sqlQuery}

    And its result in JSON format:
    ${JSON.stringify(rows)}

    Your task is:
    - Generate a concise, accurate natural language answer explaining the output.
    - Provide an appropriate visualization description as JSON, including type (e.g., pie, bar), labels, and values.
    - Return ONLY a valid JSON object (no explanations, no markdown):

    {
      "content": "string, the natural language answer",
      "visualizations": {
        "type": "chart type",
        "labels": [...],
        "values": [...]
      },
      "data": [...],  // optional tabular data, can be the rows or subset
      "sql": "${sqlQuery}"
    }
  `;

  console.log('Generated prompt for Gemini:', prompt);

  let geminiResponse = '';
  try {
    geminiResponse = await askGemini(prompt);
    console.log('Received response from Gemini:', geminiResponse);

    // Clean the response to remove Markdown formatting
    geminiResponse = geminiResponse.replace(/```(?:json)?/g, '').trim(); // Remove ```json or ```
    console.log('Cleaned response from Gemini:', geminiResponse);

    // Parse the cleaned response as JSON
    const jsonAnswer = JSON.parse(geminiResponse);
    console.log('Parsed JSON response from Gemini:', jsonAnswer);

    return jsonAnswer;
  } catch (e) {
    console.error('Error while processing Gemini response:', e.message);
    throw new Error('Failed to process Gemini response: ' + e.message);
  }
}
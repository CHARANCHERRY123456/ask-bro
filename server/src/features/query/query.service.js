// features/query/query.service.js
import { askGemini } from '../../utils/geminiClient.js';
import pool from '../../db.js';

export async function processQuestion(question, metadata) {
  console.log('processQuestion called with:', { question, metadata });

  const prompt = `
    You are Linga, a highly experienced PostgreSQL SQL query generator. You help users ask complex questions on a database with the following challenges:
    - The schema is unreliable, with columns named col1 to col18.
    - Data is messy, with nulls, inconsistent types, and malformed values.
    - Metadata is provided and must be strictly followed.

    Your task:
    1. Understand the user's natural language question and generate a valid PostgreSQL SQL query.
    2. Use ONLY the column names from the metadata provided below.
    3. If the question includes terms like "rank," "top," or "best," dynamically calculate ranks using SQL functions like RANK() or DENSE_RANK().
    4. If the question includes a specific name (e.g., "C V Charan"), treat it as a potential value in the schema. First, identify the most relevant column(s) where this value might exist (e.g., "Name") based on the metadata. Then, generate a SQL query to fetch the relevant data.
    5. Ensure the SQL query is safe, robust, and executable without errors.
    6. Handle dirty data gracefully using functions like NULLIF, COALESCE, or TRY_CAST.
    7. If the necessary data is unavailable, return:
       SELECT 'I am unable to determine the answer because the necessary data is unavailable.' AS message;

    Metadata:
    ${JSON.stringify(metadata, null, 2)}

    Question: "${question}"

    Respond ONLY with the SQL query. Do not include explanations, markdown, or extra text.
  `;

  console.log('Generated prompt for Gemini:', prompt);

  let sqlQuery = '';
  try {
    sqlQuery = await askGemini(prompt);
    sqlQuery = sqlQuery.replace(/```(?:sql)?/g, '').trim(); // Remove ``` and optional "sql"
    console.log('Received SQL query from Gemini:', sqlQuery);
    sqlQuery = sqlQuery.trim();
  } catch (e) {
    console.error('Error while getting SQL from Gemini:', e.message);
    throw new Error('Failed to get SQL from Gemini: ' + e.message);
  }

  if (!sqlQuery || !/^(SELECT|WITH|SHOW|EXPLAIN|INSERT|UPDATE|DELETE)/i.test(sqlQuery)) {
    console.error('Invalid SQL generated by Gemini:', sqlQuery);
    throw new Error('Invalid SQL generated by Gemini.');
  }

  console.log('Validated SQL query:', sqlQuery);
  return sqlQuery;
}

export async function executeSQL(sqlQuery) {
  console.log('executeSQL called with query:', sqlQuery);

  try {
    const result = await pool.query(sqlQuery);
    console.log('Query executed successfully. Result:', result.rows);
    return result.rows;
  } catch (e) {
    console.error('Error while executing SQL query:', e.message);
    throw new Error('PostgreSQL query failed: ' + e.message);
  }
}

export async function generateAnswerFromResults(sqlQuery, rows, question) {
  console.log('generateAnswerFromResults called with:', { sqlQuery, rows, question });

  const prompt = `
    You are Linga, a 21-year-old data analyst assistant.

    Your task:
    - Answer the user's question in a concise and accurate manner based on the data provided.
    - Do NOT mention the SQL query, schema, or where the information is coming from.
    - Focus only on providing a clear and helpful response to the user's question.
    - Handle complex relationships, aggregations, and comparisons in the data.
    - If applicable, include a visualization description as JSON, including type (e.g., pie, bar, line), labels, and values.
    - Ensure the response is user-friendly and avoids technical jargon.
    - Return ONLY a valid JSON object (no explanations, no markdown):
      If asked dynamic resulets like "top 10", "best", "rank", etc., include a "visualizations" field with the chart type, labels, and values. and you can calculate it using the feidls which have the marks like e1sem1 , e2sem2 , e3sem3 you can caluclate it and give the results rank

    {
      "content": "string, the natural language answer to the user's question",
      "visualizations": {
        "type": "chart type",
        "labels": [...],
        "values": [...]
      },
      "data": [...],  // optional tabular data, can be the rows or subset
      "question": "${question}"
    }

    User's Question: "${question}"

    Data:
    ${JSON.stringify(rows, null, 2)}
  `;

  console.log('Generated prompt for Gemini:', prompt);

  let geminiResponse = '';
  try {
    geminiResponse = await askGemini(prompt);
    console.log('Received response from Gemini:', geminiResponse);

    // Clean the response to remove Markdown formatting
    geminiResponse = geminiResponse.replace(/```(?:json)?/g, '').trim(); // Remove ```json or ```
    console.log('Cleaned response from Gemini:', geminiResponse);

    // Parse the cleaned response as JSON
    const jsonAnswer = JSON.parse(geminiResponse);
    console.log('Parsed JSON response from Gemini:', jsonAnswer);

    return jsonAnswer;
  } catch (e) {
    console.error('Error while processing Gemini response:', e.message);
    throw new Error('Failed to process Gemini response: ' + e.message);
  }
}